/*

-----------------------------------------------------
|		FEDERAL UNIVERSITY OF SANTA CATARINA		|
|			C++ FOR EMBEDDED SYSTEMS				|
|			PROJECT: VENDING MACHINE				|
|		PROFESSOR: EDUARDO AUGUSTO BEZERRA			|
| 	 	 	 LEONARDO AURÉLIO BESEN					|
|			JOÃO BATISTA CORDEIRO NETO				|
----------------------------------------------------- 

*/


/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "Classes_ARM.h"
#include "MachineState.h"
#include "AdControl.h"


/* Handles of UART, RTC and RNG */
	UART_HandleTypeDef huart4; //UART interface
	RTC_HandleTypeDef hrtc; //RTC - real time clock
	RNG_HandleTypeDef hrng; //RNG - random number generator


/* Variables ---------------------------------------------------------*/
	uint16_t GPIO_Pin_EXT; //Save GPIO number in interrupts occurrence
	uint8_t status_EXT = 0; //Status of interrupt occurrence
	uint8_t state = 0; //State of the Vending Machine FSM

	uint8_t receiveNewAd = 0x00; //Status of interrupt for receiving new ads
	uint8_t status_receive_ad = 0x00; //State of the system for receiving new ads
	uint32_t randomNumber; //Keeps random number generated by RNG 
	
	
	uint8_t hour[21]; //Keeps hour gotten from ClockCalendar class
	uint8_t date[21]; //Keeps date gotten from ClockCalendar class

	//Functions generated by STM32CubeMX to configure UART, RTC and RNG
	static void MX_UART4_Init(void);
	static void MX_RTC_Init(void);
	static void MX_RNG_Init(void);


int main(void){
  /* USER OBJECTS */
  
    //Objects for low hardware configuration
	LB_SystemClock systemClock;
	LB_GPIO gpioPorts;
	LB_Hall hall;
	
	//Objects for Vending Machine system
	OutputInterface* output;
	InputInterface* input;
	MachineState* MS;
	AdControl* AD;
	ClockCalendar* clock;
	
  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	hall.hallInit();
 
  /* Configure the system clock */
	systemClock.systemClockConfig();

  /* Initialize all configured peripherals */
	gpioPorts.initGPIO();
	
	HAL_PWR_EnableBkUpAccess();//Enable PWR backup domain access (RTC,BKReg)
	__HAL_RCC_RTC_ENABLE();//Enable RTC.
	
	//UART, RTC and RNG initialization
	MX_UART4_Init();
	MX_RTC_Init();
	MX_RNG_Init();
	
	
	//Objects instantiation for Vending Machine system
	#ifdef OUTPUT_LCD
		output = new LB_Lcd;
	#endif
	#ifdef OUTPUT_UART
		output = new LB_Uart;
	#endif
	
	/*
		--- ATENTION ---
	InputInterface class is not being used in this project because it has only one input - GPIO ports
	We did not deleted this class from the project because when we do it, it causes an hard fault error on the board processor.
  */
	/*----  NOT USED ------*/
	input = new InputInterfaceARM;
	/*---------------------*/
	
	MS = new MachineState(output);
	AD = new AdControl(output, input);
	
	/*DEBUG
	char adv3[] = "--Leonardo Besen--";
	Ad ad3(adv3);
	*/
	
  while (1)
  {
		/* DEBUG FOR HARD FAULT - FULL MEMORY
		HAL_Delay(10);
		AD->displayAds.insertAfterLast(ad3);
		*/
		
		//Send ads to the output interface (LCD or UART)
		//Delay between ads = 1.5 seconds
		if(state != 0x07 && receiveNewAd == 0x00){
			HAL_Delay(1500);
			AD->sendAdToDisplay(randomNumber, hour, date);
			AD->getAdFromDisplay();
		} 
		//Get new state of the vending machine when GPIO interrupt detected
		if(status_EXT == 1 && receiveNewAd == 0x00){
			status_EXT = 0;
			state = MS->nextState(GPIO_Pin_EXT);
			HAL_Delay(1000);
		}
		//Get new ad informed by the user
		if(status_EXT == 1){
			status_EXT = 0;
			if(receiveNewAd == 0x01){
				status_receive_ad = AD->getAdFromUser(GPIO_Pin_EXT);
				if(status_receive_ad == 0x01)
					receiveNewAd = 0x00;
			}
		}
		
		//Generate a random number
		//When the number is ready, an interrupt occurs
		HAL_RNG_GenerateRandomNumber_IT(&hrng);
		
  		//Get clock and date of RTC to display between ads
		clock = new ClockCalendar;
		clock->readClock(hour);
		clock->readCalendar(date);
		delete clock;
	}

}

//Interrupt callback
//Identifies what GPIO pin was pressed
void HAL_GPIO_EXTI_Callback (uint16_t GPIO_Pin)
{
	status_EXT = 1;
	switch(GPIO_Pin){
		case GPIO_PIN_1: //BUTTON_M025 - GPIO PC1
			GPIO_Pin_EXT = GPIO_PIN_1;
			break;
		case GPIO_PIN_4: //BUTTON_M050 - GPIO PD4
			GPIO_Pin_EXT = GPIO_PIN_4;
			break;
		case GPIO_PIN_5: //BUTTON_M100 - GPIO PD5
			GPIO_Pin_EXT = GPIO_PIN_5;
			break;
		case GPIO_PIN_11: //BUTTON_DEV - GPIO PC11
			GPIO_Pin_EXT = GPIO_PIN_11;
			break;
		case GPIO_PIN_2: //BUTTON_MEET - GPIO PD2
			GPIO_Pin_EXT = GPIO_PIN_2;
			break;
		case GPIO_PIN_9: //BUTTON_ETIRPS - GPIO PG9
			GPIO_Pin_EXT = GPIO_PIN_9;
			break;
		case GPIO_PIN_7: //BUTTON_STOCK - GPIO PD7
			GPIO_Pin_EXT = GPIO_PIN_7;
			break;
		case GPIO_PIN_8: //BUTTON_STOCK - GPIO PD7
			GPIO_Pin_EXT = GPIO_PIN_8;
			break;
		case GPIO_PIN_3: //BUTTON_AD_RECEIVE - GPIO PC3
			GPIO_Pin_EXT = GPIO_PIN_3;
			receiveNewAd = 0x01;
			break;
		default:
			break;
	}
}
//Call back of RNG
void HAL_RNG_ReadyDataCallback(RNG_HandleTypeDef *hrng, uint32_t random32bit)
{
	//Get new random number generated by RNG
	randomNumber = random32bit;

}

//RNG init
static void MX_RNG_Init(void)
{

  hrng.Instance = RNG;
  if (HAL_RNG_Init(&hrng) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

}

//RTC init
static void MX_RTC_Init(void)
{

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_TimeTypeDef sTime;
  RTC_DateTypeDef sDate;

  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */

    /**Initialize RTC Only 
    */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

    /**Initialize RTC and set the Time and Date 
    */
  sTime.Hours = 0x0E;
  sTime.Minutes = 0x22;
  sTime.Seconds = 0x38;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }
  /* USER CODE BEGIN RTC_Init 3 */

  /* USER CODE END RTC_Init 3 */

  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
  sDate.Month = RTC_MONTH_NOVEMBER;
  sDate.Date = 0x1E;
  sDate.Year = 0x18;

  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }
  /* USER CODE BEGIN RTC_Init 4 */

  /* USER CODE END RTC_Init 4 */

}

//UART init
static void MX_UART4_Init(void)
{

  huart4.Instance = UART4;
  huart4.Init.BaudRate = 9600;
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
  huart4.Init.StopBits = UART_STOPBITS_1;
  huart4.Init.Parity = UART_PARITY_NONE;
  huart4.Init.Mode = UART_MODE_TX_RX;
  huart4.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart4.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart4) != HAL_OK)
  {
    _Error_Handler(__FILE__, __LINE__);
  }

}

/**
  * @brief  This function is executed in case of error occurrence.
  * @param  file: The file name as string.
  * @param  line: The line in file as a number.
  * @retval None
  */
void _Error_Handler(char *file, int line)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while(1)
  {

  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t* file, uint32_t line)
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

